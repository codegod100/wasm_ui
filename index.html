<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Odin WASM UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    #app { max-width: 560px; }
    .chat-header { font-weight: 600; margin-bottom: 8px; }
    .chat-list { border: 1px solid #ddd; border-radius: 8px; padding: 8px; height: 260px; overflow-y: auto; }
    .chat-row { padding: 4px 6px; border-bottom: 1px dashed #eee; }
    .chat-row:last-child { border-bottom: none; }
    .chat-actions { margin-top: 8px; }
    .chat-actions button { margin-right: 8px; padding: 4px 8px; }
    /* Loading spinner */
    .loading { display: inline-flex; align-items: center; gap: 8px; color: #555; }
    .spinner { width: 18px; height: 18px; border: 3px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
  <script src="odin.js"></script>
  <script>
    // Handle OAuth redirect results both for popup and full-window flows
    (function () {
      try {
        if (location.search && /[?&](code|error)=/.test(location.search)) {
          const p = new URLSearchParams(location.search);
          const msg = {
            source: 'bsky_oauth',
            code: p.get('code') || '',
            state: p.get('state') || '',
            iss: p.get('iss') || '',
            error: p.get('error') || '',
            error_description: p.get('error_description') || '',
            error_uri: p.get('error_uri') || ''
          };
          const narr = (...args) => { try { console.log('[oauth]', ...args); const line = args.map(a=>{ if(a==null) return String(a); if(typeof a==='string') return a; try{return JSON.stringify(a);}catch{return String(a);} }).join(' '); const prev = sessionStorage.getItem('authLog')||''; sessionStorage.setItem('authLog', prev + line + '\n'); } catch {} };
          narr('Callback', { state: msg.state, iss: msg.iss, hasCode: !!msg.code, hasErr: !!msg.error });
          if (window.opener) {
            try { window.opener.postMessage(msg, '*'); } catch {}
            // On error, keep window open so user can read details
            if (!msg.error) {
              document.write('You may close this window.');
              setTimeout(function () { try { window.close(); } catch {} }, 10);
            }
          } else if (msg.code && msg.state && !msg.error) {
            // Full-window redirect: perform token exchange in browser using DPoP
            const b64u = (u8) => {
              if (!(u8 instanceof Uint8Array)) throw new Error('b64u expects Uint8Array');
              let s = '';
              for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
              return btoa(s).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
            };
            const enc = (s) => new TextEncoder().encode(s);
            const toHex = (u8) => Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join('');
            const uuid = () => { const a=new Uint8Array(16); crypto.getRandomValues(a); a[6]=(a[6]&0x0f)|0x40; a[8]=(a[8]&0x3f)|0x80; const h=toHex(a); return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`; };
            const derToJose = (der) => {
              const b = new Uint8Array(der);
              // If already JOSE (r||s) form, just return
              if (b.length === 64) return b;
              let i = 0;
              const expect = (val) => { if (b[i++] !== val) throw new Error('DER parse error'); };
              const readLen = () => {
                let len = b[i++];
                if (len & 0x80) {
                  const n = len & 0x7f;
                  len = 0;
                  for (let j = 0; j < n; j++) { len = (len << 8) | b[i++]; }
                }
                return len;
              };
              expect(0x30); // SEQUENCE
              void readLen();
              expect(0x02); // INTEGER r
              let rlen = readLen();
              let r = b.slice(i, i + rlen); i += rlen;
              expect(0x02); // INTEGER s
              let slen = readLen();
              let s = b.slice(i, i + slen); i += slen;
              // Remove leading zero padding
              while (r.length > 0 && r[0] === 0x00) r = r.slice(1);
              while (s.length > 0 && s[0] === 0x00) s = s.slice(1);
              if (r.length > 32 || s.length > 32) throw new Error('Invalid r|s length');
              const ro = new Uint8Array(32); ro.set(r, 32 - r.length);
              const so = new Uint8Array(32); so.set(s, 32 - s.length);
              const out = new Uint8Array(64); out.set(ro, 0); out.set(so, 32);
              return out;
            };
            const state = sessionStorage.getItem('oauth_bsky_state')||'';
            try { sessionStorage.setItem('oauth_bsky_issuer', msg.iss || ''); } catch {}
            const verifier = sessionStorage.getItem('oauth_bsky_verifier')||'';
            const clientId = sessionStorage.getItem('oauth_bsky_client_id')||'http://localhost';
            const tokenEndpoint = sessionStorage.getItem('oauth_bsky_token_endpoint')||'';
            const redirectUri = sessionStorage.getItem('oauth_bsky_redirect_uri')||location.origin+'/';
            narr('Prepared', { tokenEndpoint, clientId, redirectUri, verifierLen: (verifier||'').length, codeLen: (msg.code||'').length });
            if (state !== msg.state || !verifier || !tokenEndpoint) { document.body.innerHTML='<h2>Exchange failed</h2><p>Missing verifier or state mismatch.</p>'; return; }
            const form = (obj) => Object.entries(obj).map(([k,v])=>k+'='+encodeURIComponent(v)).join('&');
            const makeDpop = async (htu, nonce) => {
              const key = await crypto.subtle.generateKey({name:'ECDSA', namedCurve:'P-256'}, true, ['sign']);
              const jwk = await crypto.subtle.exportKey('jwk', key.publicKey);
              const hdr = { typ:'dpop+jwt', alg:'ES256', jwk:{kty:jwk.kty, crv:jwk.crv, x:jwk.x, y:jwk.y} };
              const now = Math.floor(Date.now()/1000);
              const pld = { htm:'POST', htu, iat: now, jti: uuid() };
              if (nonce) pld.nonce = nonce;
              const data = b64u(enc(JSON.stringify(hdr))) + '.' + b64u(enc(JSON.stringify(pld)));
              const sigDer = new Uint8Array(await crypto.subtle.sign({name:'ECDSA', hash:'SHA-256'}, key.privateKey, enc(data)));
              const sigJose = derToJose(sigDer);
              return data + '.' + b64u(sigJose);
            };
            const tokenFetch = async (nonce) => {
              const dpop = await makeDpop(tokenEndpoint, nonce);
              const body = form({ grant_type:'authorization_code', code: msg.code, redirect_uri: redirectUri, client_id: clientId, code_verifier: verifier });
              narr('POST token', { url: tokenEndpoint, hasNonce: !!nonce });
               const r = await fetch(tokenEndpoint, { method:'POST', headers:{ 'content-type':'application/x-www-form-urlencoded', 'DPoP': dpop }, body });
              return r;
            };
            (async () => {
              let r = await tokenFetch();
              let nonce = r.headers.get('DPoP-Nonce') || r.headers.get('dpop-nonce');
              let text = await r.text();
              narr('Token resp', { status: r.status, preview: text.slice(0,200) });
              // Retry if AS requests nonce (header or error body)
              let bodyErr = {};
              try { bodyErr = JSON.parse(text) } catch {}
              if ((!r.ok) && (nonce || (bodyErr && bodyErr.error === 'use_dpop_nonce'))) {
                if (!nonce) { nonce = (r.headers.get('DPoP-Nonce') || r.headers.get('dpop-nonce')) || ''; }
                if (nonce) {
                  narr('Retry token with nonce', { nonce });
                  r = await tokenFetch(nonce);
                  text = await r.text();
                  narr('Token retry resp', { status: r.status, preview: text.slice(0,200) });
                }
              }
              if (!r.ok) { document.body.innerHTML = '<h2>Exchange failed</h2><pre>'+text.slice(0,400)+'</pre>'; return; }
              let tr={}; try { tr = JSON.parse(text); } catch {};
              narr('Token OK', { keys: Object.keys(tr), values: Object.values(tr) });
              // Resolve handle via XRPC using DID (token.sub) only — simple and direct
              let username = '';
              try {
                const did = (tr.sub || '').trim();
                narr('Using DID', { did });
                if (did) {
                  const url = 'https://api.bsky.app/xrpc/app.bsky.actor.getProfile?actor=' + encodeURIComponent(did);
                  narr('GET profile', { url });
                  const pr = await fetch(url, { method: 'GET' });
                  const ptext = await pr.text();
                  narr('Profile resp', { status: pr.status, preview: ptext.slice(0,200) });
                  if (pr.ok) {
                    const prof = JSON.parse(ptext);
                    try { sessionStorage.setItem('bskyProfile', JSON.stringify(prof)); } catch {}
                    console.log('Bluesky profile', prof);
                    if (prof && prof.handle) username = prof.handle;
                  }
                }
              } catch (e) { narr('Profile fetch error', String(e)); }
              let didFromAT = '';
              try {
                if (tr.access_token && tr.access_token.includes('.')) {
                  const atParts = tr.access_token.split('.');
                  if (atParts.length >= 2) {
                    const atDec = JSON.parse(new TextDecoder().decode(b64uToBytes(atParts[1])));
                    if (atDec && atDec.sub) didFromAT = String(atDec.sub);
                    narr('access_token decoded', { hasSub: !!didFromAT });
                  }
                }
              } catch (e) { narr('access_token decode failed', String(e)); }
              if (!username && tr.id_token) {
                try { const [,p]=tr.id_token.split('.'); const dec = JSON.parse(new TextDecoder().decode(b64uToBytes(p))); username = dec.handle || dec.did || dec.sub || ''; narr('id_token decoded', { haveHandle: !!dec.handle, haveDid: !!dec.did }); } catch (e) { narr('id_token decode failed', String(e));}
              }
              // If no handle yet, fetch profile via XRPC to resolve handle
              if (!tr.handle) {
                try {
                  const issuer = (sessionStorage.getItem('oauth_bsky_issuer') || msg.iss || 'https://bsky.social').replace(/\/$/, '');
                  const actor = (tr.handle || tr.sub || tr.did || didFromAT || '').trim();
                  const tryProfile = async (base) => {
                    const url = base.replace(/\/$/, '') + '/xrpc/app.bsky.actor.getProfile?actor=' + encodeURIComponent(actor);
                    narr('GET profile', { url });
                    // AppView is public; do not send Authorization/DPoP there.
                    if (base.startsWith('https://api.bsky.app')) {
                      const pr = await fetch(url, { method:'GET' });
                      const ptext = await pr.text();
                      narr('Profile resp (appview)', { status: pr.status, preview: ptext.slice(0,200) });
                      return { ok: pr.ok, text: ptext };
                    }
                    // For issuer/PDS, send DPoP-bound access token
                    const resourceFetch = async (nonce) => {
                      const dpop = await makeDpop(url, nonce);
                      const r = await fetch(url, { method:'GET', headers:{ 'Authorization': 'DPoP ' + tr.access_token, 'DPoP': dpop } });
                      return r;
                    };
                    let pr = await resourceFetch();
                    let ptext = await pr.text();
                    narr('Profile resp (issuer)', { status: pr.status, preview: ptext.slice(0,200) });
                    if (!pr.ok) {
                      const n = pr.headers.get('DPoP-Nonce') || pr.headers.get('dpop-nonce');
                      let perr={}; try { perr = JSON.parse(ptext) } catch {}
                      if (n || (perr && perr.error === 'use_dpop_nonce')) {
                        narr('Retry profile with nonce', { nonce: n });
                        pr = await resourceFetch(n||'');
                        ptext = await pr.text();
                        narr('Profile retry resp', { status: pr.status, preview: ptext.slice(0,200) });
                      }
                    }
                    return { ok: pr.ok, text: ptext };
                  };
                  let res1 = await tryProfile('https://api.bsky.app');
                  if (!res1.ok) {
                    narr('Profile fallback to issuer');
                    res1 = await tryProfile(issuer);
                  }
                  if (res1.ok) {
                    const prof = JSON.parse(res1.text);
                    try { sessionStorage.setItem('bskyProfile', JSON.stringify(prof)); } catch {}
                    console.log('Bluesky profile', prof);
                    if (prof && prof.handle) username = prof.handle;
                  } else {
                    console.debug('Bluesky profile fetch failed (both hosts)');
                  }
                } catch (e) {
                  console.debug('profile fetch skipped', e);
                  narr('Profile fetch error', String(e));
                }
              }
              // Final fallback: avoid showing DID; stick to handle if present, else 'bsky'
              if (!username) username = tr.handle || 'bsky';
              narr('Username chosen', { username });
              // Mint local app token from server for convenience
              try {
                const j = await (await fetch('/api/auth/token?sub='+encodeURIComponent(username))).json();
                if (j && j.token) sessionStorage.setItem('authToken', j.token);
              } catch {}
              sessionStorage.setItem('authUsername', username);
              try { history.replaceState({}, '', '/'); } catch {}
              narr('Reload app');
              location.href = '/';
            })();
          }
        }
      } catch {}
    })();
  </script>
  <script>
    // Hold a WasmMemoryInterface so we can access exports for callbacks
    const wmi = new odin.WasmMemoryInterface();

    // Provide imports for Odin's `foreign import "js"` stubs via extra imports
    // Simple handle table for DOM nodes (WASM passes u32 handles, not JS objects)
    const H = { next: 1, table: Object.create(null) };
    const hput = (obj) => { const id = H.next++; H.table[id] = obj; return id; };
    const hget = (id) => H.table[id];

    const s = (ptr, len) => wmi.loadString(ptr, len);

    const extraImports = {
      js: {
        js_query_selector: (sel_ptr, sel_len) => hput(document.querySelector(s(sel_ptr, sel_len))),
        js_create_element: (tag_ptr, tag_len) => hput(document.createElement(s(tag_ptr, tag_len))),
        js_create_text_node: (text_ptr, text_len) => hput(document.createTextNode(s(text_ptr, text_len))),
        js_set_attr: (el, name_ptr, name_len, value_ptr, value_len) => hget(el)?.setAttribute(s(name_ptr, name_len), s(value_ptr, value_len)),
        js_append_child: (parent, child) => hget(parent)?.appendChild(hget(child)),
        js_remove_children: (el) => { const e = hget(el); if (!e) return; while (e.firstChild) e.removeChild(e.firstChild); },
        js_add_event: (el, ev_ptr, ev_len, id) => {
          const e = hget(el);
          if (!e) return;
          const name = s(ev_ptr, ev_len);
          if (name === 'enter') {
            e.addEventListener('keydown', (evt) => {
              if (evt.key === 'Enter') {
                if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                  wmi.exports.on_event(id);
                }
              }
            });
          } else {
            e.addEventListener(name, () => {
              if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                wmi.exports.on_event(id);
              }
            });
          }
        },
        js_get_value_by_id: (id_ptr, id_len, dst_ptr, dst_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return 0;
          const val = (el.value != null ? String(el.value) : '');
          const toWrite = val.slice(0, dst_len);
          return wmi.storeString(dst_ptr, toWrite);
        },
        js_set_value_by_id: (id_ptr, id_len, value_ptr, value_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.value = s(value_ptr, value_len);
        },
        js_focus_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (el && typeof el.focus === 'function') el.focus();
        },
        js_scroll_to_bottom_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.scrollTop = el.scrollHeight;
        },
        // Fetch bridge (very simple, last-result cache)
        js_fetch_get: (url_ptr, url_len, cb_id) => {
          const url = s(url_ptr, url_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = {};
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'GET', headers })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_fetch_post_json: (url_ptr, url_len, body_ptr, body_len, cb_id) => {
          const url = s(url_ptr, url_len);
          const body = s(body_ptr, body_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = { 'content-type': 'application/json' };
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'POST', headers, body })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_get_fetch_body: (dst_ptr, dst_len) => {
          const txt = (window.__fetchCache && window.__fetchCache.body) || '';
          return wmi.storeString(dst_ptr, txt.slice(0, dst_len));
        },
        js_get_fetch_status: () => (window.__fetchCache && window.__fetchCache.status) || 0,
        js_set_auth_token: (tok_ptr, tok_len) => {
          window.__authToken = s(tok_ptr, tok_len);
        },
        js_has_auth_token: () => !!window.__authToken,
        js_set_current_user: (name_ptr, name_len) => {
          window.__currentUser = s(name_ptr, name_len);
        },
        js_get_current_user: (dst_ptr, dst_len) => {
          const name = window.__currentUser || '';
          return wmi.storeString(dst_ptr, name.slice(0, dst_len));
        },
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      flushAuthLog();
      const pre = null;
      // Restore session auth (if present)
      try {
        const t = sessionStorage.getItem('authToken');
        if (t) window.__authToken = t;
        const u = sessionStorage.getItem('authUsername');
        if (u) window.__currentUser = u;
      } catch {}
      // Build path must match the output you generate with `odin build` below
      odin.runWasm('./ui.wasm', pre, extraImports, wmi).then(() => {
        // Notify WASM to pick up restored username, if any
        if (window.__currentUser && wmi?.exports?.on_event) wmi.exports.on_event(60);
      }).catch(err => {
        const app = document.getElementById('app');
        if (app) app.innerHTML = '<div class="loading"><div class="spinner"></div><span>Failed to load UI</span></div>';
        console.error('Failed to run WASM', err);
      });
    });
  </script>
  </head>
  <body>
    <h1>Odin WASM UI</h1>
    <div id="app">
      <div class="loading">
        <div class="spinner"></div>
        <span>Loading UI…</span>
      </div>
    </div>
    <div style="margin-top:16px; padding-top:8px; border-top:1px solid #eee;">
      <!-- Passkey actions disabled for now -->
      <button id="btn-passkey-register" style="display:none">Register Passkey</button>
      <button id="btn-passkey-login" style="display:none">Sign in with Passkey</button>
      <button id="btn-bsky-login">Sign in with Bluesky</button>
      <div id="auth-status" style="margin-top:8px; min-height:20px; color:#6b7280;"></div>
      <pre id="auth-log" style="margin-top:6px; max-height:160px; overflow:auto; background:#0b1020; color:#d1d5db; padding:8px; border-radius:6px; font-size:12px;"></pre>
    </div>
    <script>
      // Basic styling hooks used by the Odin side
      const styleObserver = new MutationObserver(() => {
        const app = document.getElementById('app');
        if (!app) return;
        // Add classes to elements by their order to make it look chatty
        const [header, list, actions] = app.children;
        if (header) header.classList.add('chat-header');
        if (list)   list.classList.add('chat-list');
        if (list)   [...list.children].forEach(c => c.classList.add('chat-row'));
        if (actions) actions.classList.add('chat-actions');
      });
      styleObserver.observe(document.getElementById('app'), { childList: true, subtree: true });
    </script>
    <script>
      // Minimal helpers for base64url <-> ArrayBuffer
      const b64uToBytes = (s) => {
        s = s.replace(/-/g, '+').replace(/_/g, '/');
        // pad
        while (s.length % 4) s += '=';
        const bin = atob(s);
        const u8 = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
        return u8;
      };
      const bytesToB64u = (u8) => {
        let s = '';
        for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
        return btoa(s).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
      };

      // Map server JSON into WebAuthn options
      const toCreationOptions = (opts) => ({
        rp: opts.rp,
        user: {
          id: b64uToBytes(opts.user.id_b64),
          name: opts.user.name,
          displayName: opts.user.displayName,
        },
        challenge: b64uToBytes(opts.challenge_b64),
        pubKeyCredParams: opts.pubKeyCredParams,
        timeout: opts.timeout,
        attestation: opts.attestation,
        authenticatorSelection: opts.authenticatorSelection,
        extensions: { credProps: true },
        excludeCredentials: (opts.excludeCredentials||[]).map(e => ({ type: e.type, id: b64uToBytes(e.id_b64) })),
      });

      const toRequestOptions = (opts) => ({
        challenge: b64uToBytes(opts.challenge_b64),
        timeout: opts.timeout,
        userVerification: opts.userVerification,
        allowCredentials: (opts.allowCredentials||[]).map(a => ({ type: a.type, id: b64uToBytes(a.id_b64), transports: (a.transports||'').split(',').filter(Boolean) })),
      });

      const postJson = async (url, body) => {
        const r = await fetch(url, { method: 'POST', headers: { 'content-type':'application/json' }, body: JSON.stringify(body) });
        const text = await r.text();
        if (!text) {
          if (!r.ok) throw new Error(`HTTP ${r.status} empty body`);
          return {};
        }
        try {
          const json = JSON.parse(text);
          if (!r.ok) throw new Error(json && json.error ? json.error : `HTTP ${r.status}`);
          return json;
        } catch (e) {
          if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,160)}`);
          throw e;
        }
      };

      // Prevent overlapping WebAuthn requests (spec forbids concurrent calls)
      let __webauthnPending = false;
      let __webauthnAbortCtrl = null;
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      const setAuthStatus = (msg, kind = 'info') => {
        const el = document.getElementById('auth-status');
        if (!el) return;
        el.textContent = msg || '';
        el.style.color = kind === 'error' ? '#b91c1c' : (kind === 'success' ? '#065f46' : '#6b7280');
      };
      const appendAuthLog = (...args) => {
        try {
          console.log('[oauth]', ...args);
          const el = document.getElementById('auth-log');
          const line = args.map(a => {
            if (a == null) return String(a);
            if (typeof a === 'string') return a;
            try { return JSON.stringify(a); } catch { return String(a); }
          }).join(' ');
          if (el) { el.textContent += line + '\n'; el.scrollTop = el.scrollHeight; }
          const prev = sessionStorage.getItem('authLog') || '';
          sessionStorage.setItem('authLog', prev + line + '\n');
        } catch {}
      };
      const flushAuthLog = () => { try { const el = document.getElementById('auth-log'); const prev = sessionStorage.getItem('authLog')||''; if (el && prev) { el.textContent += prev; el.scrollTop = el.scrollHeight; sessionStorage.removeItem('authLog'); } } catch {} };

      // Bluesky OAuth (popup + postMessage)
      const onBskyLoginClick = async () => {
        try {
          appendAuthLog('Start /api/auth/bsky/start');
          setAuthStatus('Starting Bluesky sign-in…');
          const start = await postJson('/api/auth/bsky/start', {});
          if (!start || !start.url) { setAuthStatus('OAuth start failed', 'error'); return; }
          appendAuthLog('Start OK', { url: start.url, state: start.state, client_id: start.client_id, token_endpoint: start.token_endpoint, redirect_uri: start.redirect_uri, scope: start.scope });
          appendAuthLog('Redirecting to authorize URL');
          try {
            sessionStorage.setItem('oauth_bsky_state', start.state || '');
            sessionStorage.setItem('oauth_bsky_verifier', start.code_verifier || '');
            sessionStorage.setItem('oauth_bsky_client_id', start.client_id || '');
            sessionStorage.setItem('oauth_bsky_token_endpoint', start.token_endpoint || '');
            sessionStorage.setItem('oauth_bsky_redirect_uri', start.redirect_uri || '');
            sessionStorage.setItem('oauth_bsky_scope', start.scope || '');
          } catch {}
          // Navigate in the top window instead of a popup
          window.location.href = start.url;
          return;
          // (Popup flow kept below for reference, but disabled by early return)
          const w = 500, h = 640;
          const y = window.top.outerHeight/2 + window.top.screenY - ( h/2);
          const x = window.top.outerWidth/2 + window.top.screenX - ( w/2);
          const pop = window.open(start.url, 'bsky_oauth', `width=${w},height=${h},left=${x},top=${y}`);
          if (!pop) { setAuthStatus('Popup blocked; allow popups for this site', 'error'); return; }
          const onMsg = async (ev) => {
            const d = ev && ev.data || {};
            if (d && d.source === 'bsky_oauth') {
              window.removeEventListener('message', onMsg);
              try { pop.close(); } catch {}
              if (d.error) {
                const desc = d.error_description ? decodeURIComponent(d.error_description) : '';
                console.debug('OAuth error', d);
                setAuthStatus(`Bluesky denied access: ${d.error}${desc ? ' — ' + desc : ''}`, 'error');
                return;
              }
              if (!d.code || !d.state) { setAuthStatus('OAuth missing code/state', 'error'); return; }
              try {
                setAuthStatus('Finalizing sign-in…');
                const fin = await postJson('/api/auth/bsky/exchange', { code: d.code, state: d.state, issuer: d.iss || '' });
                if (fin && fin.username) {
                  window.__currentUser = fin.username;
                  try { sessionStorage.setItem('authUsername', fin.username); } catch {}
                  if (fin.token) {
                    window.__authToken = fin.token;
                    try { sessionStorage.setItem('authToken', fin.token); } catch {}
                  }
                  if (wmi?.exports?.on_event) wmi.exports.on_event(60);
                  setAuthStatus(`Signed in as ${fin.username}`, 'success');
                  try { window.focus(); } catch {}
                } else {
                  setAuthStatus('Exchange did not return a user', 'error');
                }
              } catch (e) {
                const msg = (e && e.message) ? e.message : String(e);
                setAuthStatus('Exchange failed: ' + msg, 'error');
              }
            }
          };
          window.addEventListener('message', onMsg);
        } catch (e) {
          const msg = (e && e.message) ? e.message : String(e);
          setAuthStatus('OAuth start failed: ' + msg, 'error');
        }
      };

      const onRegisterClick = async () => {
        const username = prompt('Username for passkey registration:')?.trim();
        if (!username) return;
        try {
          const start = await postJson('/api/auth/passkey/register/start', { username });
          const cred = await navigator.credentials.create({ publicKey: toCreationOptions(start) });
          if (!cred) throw new Error('no credential created');
          try {
            const ext = cred.getClientExtensionResults ? cred.getClientExtensionResults() : {};
            if (ext && ext.credProps) {
              console.log('credProps', ext.credProps);
              // Log whether a resident key was stored (for debugging)
              if (typeof ext.credProps.rk !== 'undefined') {
                console.log('discoverable credential:', !!ext.credProps.rk);
              }
            }
          } catch {}
          const att = cred.response;
          const payload = {
            username,
            id_b64: cred.id,
            raw_id_b64: bytesToB64u(new Uint8Array(cred.rawId)),
            type: cred.type,
            response: {
              attestationObject_b64: bytesToB64u(new Uint8Array(att.attestationObject)),
              clientDataJSON_b64: bytesToB64u(new Uint8Array(att.clientDataJSON)),
            }
          };
          const fin = await postJson('/api/auth/passkey/register/finish', payload);
          console.log('register finish', fin);
        } catch (e) {
          console.error('register error', e);
        }
      };

      const onLoginClick = async () => {
        // Usernameless login on click: show passkey picker (no username fallback here)
        // If a background conditional request is in-flight, abort it so this click can take over.
        if (__webauthnAbortCtrl) {
          try { __webauthnAbortCtrl.abort(); } catch {}
          // Wait briefly for the abort to propagate and clear pending flag
          const t0 = Date.now();
          while (__webauthnPending && Date.now() - t0 < 500) { await sleep(10); }
        }
        if (__webauthnPending) { console.debug('WebAuthn still settling; try again'); return; }
        __webauthnPending = true;
        const btn = document.getElementById('btn-passkey-login');
        const prev = btn ? btn.textContent : '';
        if (btn) { btn.disabled = true; btn.textContent = 'Opening passkey…'; }
        setAuthStatus('Contacting server…');
        try {
          const start = await postJson('/api/auth/passkey/login/conditional/start', {});
          const assertion = await navigator.credentials.get({
            mediation: 'optional', // modal picker on click
            publicKey: toRequestOptions({
              challenge_b64: start.challenge_b64,
              timeout: start.timeout,
              userVerification: start.userVerification,
              allowCredentials: [],
            })
          });
          if (!assertion) { console.info('No passkeys available for this site.'); return; }
          const res = assertion.response;
          const payload = {
            username: '',
            id_b64: assertion.id,
            raw_id_b64: bytesToB64u(new Uint8Array(assertion.rawId)),
            type: assertion.type,
            response: {
              authenticatorData_b64: bytesToB64u(new Uint8Array(res.authenticatorData)),
              clientDataJSON_b64: bytesToB64u(new Uint8Array(res.clientDataJSON)),
              signature_b64: bytesToB64u(new Uint8Array(res.signature)),
              userHandle_b64: res.userHandle ? bytesToB64u(new Uint8Array(res.userHandle)) : ''
            }
          };
          const fin = await postJson('/api/auth/passkey/login/finish', payload);
          console.log('login finish (usernameless)', fin);
          if (fin && fin.username) {
            // Persist session + push to WASM and trigger UI update
            window.__currentUser = fin.username;
            try { sessionStorage.setItem('authUsername', fin.username); } catch {}
            if (fin.token) {
              window.__authToken = fin.token;
              try { sessionStorage.setItem('authToken', fin.token); } catch {}
            }
            if (wmi?.exports?.on_event) wmi.exports.on_event(60);
            setAuthStatus(`Signed in as ${fin.username}`, 'success');
          }
          // no alert; UI updates via username/token set above
        } catch (e) {
          console.error('usernameless login error', e);
          const msg = (e && e.message) ? e.message : String(e);
          setAuthStatus(`Sign-in failed: ${msg}`, 'error');
        } finally {
          __webauthnPending = false;
          if (btn) { btn.disabled = false; btn.textContent = prev; }
        }
      };

      // Passkeys disabled: no event listeners
      // document.getElementById('btn-passkey-register').addEventListener('click', onRegisterClick);
      // document.getElementById('btn-passkey-login').addEventListener('click', onLoginClick);
      document.getElementById('btn-bsky-login').addEventListener('click', onBskyLoginClick);

      // Passkeys disabled: conditional mediation skipped
    </script>
    
  </body>
</html>
