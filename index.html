<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Odin WASM UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    #app { max-width: 560px; }
    .chat-header { font-weight: 600; margin-bottom: 8px; }
    .chat-list { border: 1px solid #ddd; border-radius: 8px; padding: 8px; height: 260px; overflow-y: auto; }
    .chat-row { padding: 4px 6px; border-bottom: 1px dashed #eee; }
    .chat-row:last-child { border-bottom: none; }
    .chat-actions { margin-top: 8px; }
    .chat-actions button { margin-right: 8px; padding: 4px 8px; }
    /* Loading spinner */
    .loading { display: inline-flex; align-items: center; gap: 8px; color: #555; }
    .spinner { width: 18px; height: 18px; border: 3px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
  <script src="odin.js"></script>
  <script>
    // Hold a WasmMemoryInterface so we can access exports for callbacks
    const wmi = new odin.WasmMemoryInterface();

    // Provide imports for Odin's `foreign import "js"` stubs via extra imports
    // Simple handle table for DOM nodes (WASM passes u32 handles, not JS objects)
    const H = { next: 1, table: Object.create(null) };
    const hput = (obj) => { const id = H.next++; H.table[id] = obj; return id; };
    const hget = (id) => H.table[id];

    const s = (ptr, len) => wmi.loadString(ptr, len);

    const extraImports = {
      js: {
        js_query_selector: (sel_ptr, sel_len) => hput(document.querySelector(s(sel_ptr, sel_len))),
        js_create_element: (tag_ptr, tag_len) => hput(document.createElement(s(tag_ptr, tag_len))),
        js_create_text_node: (text_ptr, text_len) => hput(document.createTextNode(s(text_ptr, text_len))),
        js_set_attr: (el, name_ptr, name_len, value_ptr, value_len) => hget(el)?.setAttribute(s(name_ptr, name_len), s(value_ptr, value_len)),
        js_append_child: (parent, child) => hget(parent)?.appendChild(hget(child)),
        js_remove_children: (el) => { const e = hget(el); if (!e) return; while (e.firstChild) e.removeChild(e.firstChild); },
        js_add_event: (el, ev_ptr, ev_len, id) => {
          const e = hget(el);
          if (!e) return;
          const name = s(ev_ptr, ev_len);
          if (name === 'enter') {
            e.addEventListener('keydown', (evt) => {
              if (evt.key === 'Enter') {
                if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                  wmi.exports.on_event(id);
                }
              }
            });
          } else {
            e.addEventListener(name, () => {
              if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                wmi.exports.on_event(id);
              }
            });
          }
        },
        js_get_value_by_id: (id_ptr, id_len, dst_ptr, dst_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return 0;
          const val = (el.value != null ? String(el.value) : '');
          const toWrite = val.slice(0, dst_len);
          return wmi.storeString(dst_ptr, toWrite);
        },
        js_set_value_by_id: (id_ptr, id_len, value_ptr, value_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.value = s(value_ptr, value_len);
        },
        js_focus_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (el && typeof el.focus === 'function') el.focus();
        },
        js_scroll_to_bottom_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.scrollTop = el.scrollHeight;
        },
        // Fetch bridge (very simple, last-result cache)
        js_fetch_get: (url_ptr, url_len, cb_id) => {
          const url = s(url_ptr, url_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = {};
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'GET', headers })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_fetch_post_json: (url_ptr, url_len, body_ptr, body_len, cb_id) => {
          const url = s(url_ptr, url_len);
          const body = s(body_ptr, body_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = { 'content-type': 'application/json' };
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'POST', headers, body })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_get_fetch_body: (dst_ptr, dst_len) => {
          const txt = (window.__fetchCache && window.__fetchCache.body) || '';
          return wmi.storeString(dst_ptr, txt.slice(0, dst_len));
        },
        js_get_fetch_status: () => (window.__fetchCache && window.__fetchCache.status) || 0,
        js_set_auth_token: (tok_ptr, tok_len) => {
          window.__authToken = s(tok_ptr, tok_len);
        },
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      const pre = null;
      // Build path must match the output you generate with `odin build` below
      odin.runWasm('./ui.wasm', pre, extraImports, wmi).catch(err => {
        const app = document.getElementById('app');
        if (app) app.innerHTML = '<div class="loading"><div class="spinner"></div><span>Failed to load UI</span></div>';
        console.error('Failed to run WASM', err);
      });
    });
  </script>
  </head>
  <body>
    <h1>Odin WASM UI</h1>
    <div id="app">
      <div class="loading">
        <div class="spinner"></div>
        <span>Loading UIâ€¦</span>
      </div>
    </div>
    <div style="margin-top:16px; padding-top:8px; border-top:1px solid #eee;">
      <button id="btn-passkey-register">Register Passkey</button>
      <button id="btn-passkey-login">Sign in with Passkey</button>
    </div>
    <script>
      // Basic styling hooks used by the Odin side
      const styleObserver = new MutationObserver(() => {
        const app = document.getElementById('app');
        if (!app) return;
        // Add classes to elements by their order to make it look chatty
        const [header, list, actions] = app.children;
        if (header) header.classList.add('chat-header');
        if (list)   list.classList.add('chat-list');
        if (list)   [...list.children].forEach(c => c.classList.add('chat-row'));
        if (actions) actions.classList.add('chat-actions');
      });
      styleObserver.observe(document.getElementById('app'), { childList: true, subtree: true });
    </script>
    <script>
      // Minimal helpers for base64url <-> ArrayBuffer
      const b64uToBytes = (s) => {
        s = s.replace(/-/g, '+').replace(/_/g, '/');
        // pad
        while (s.length % 4) s += '=';
        const bin = atob(s);
        const u8 = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
        return u8;
      };
      const bytesToB64u = (u8) => {
        let s = '';
        for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
        return btoa(s).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
      };

      // Map server JSON into WebAuthn options
      const toCreationOptions = (opts) => ({
        rp: opts.rp,
        user: {
          id: b64uToBytes(opts.user.id_b64),
          name: opts.user.name,
          displayName: opts.user.displayName,
        },
        challenge: b64uToBytes(opts.challenge_b64),
        pubKeyCredParams: opts.pubKeyCredParams,
        timeout: opts.timeout,
        attestation: opts.attestation,
        excludeCredentials: (opts.excludeCredentials||[]).map(e => ({ type: e.type, id: b64uToBytes(e.id_b64) })),
      });

      const toRequestOptions = (opts) => ({
        challenge: b64uToBytes(opts.challenge_b64),
        timeout: opts.timeout,
        userVerification: opts.userVerification,
        allowCredentials: (opts.allowCredentials||[]).map(a => ({ type: a.type, id: b64uToBytes(a.id_b64), transports: (a.transports||'').split(',').filter(Boolean) })),
      });

      const postJson = async (url, body) => {
        const r = await fetch(url, { method: 'POST', headers: { 'content-type':'application/json' }, body: JSON.stringify(body) });
        const text = await r.text();
        if (!text) {
          if (!r.ok) throw new Error(`HTTP ${r.status} empty body`);
          return {};
        }
        try {
          const json = JSON.parse(text);
          if (!r.ok) throw new Error(json && json.error ? json.error : `HTTP ${r.status}`);
          return json;
        } catch (e) {
          if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,160)}`);
          throw e;
        }
      };

      const onRegisterClick = async () => {
        const username = prompt('Username for passkey registration:')?.trim();
        if (!username) return;
        try {
          const start = await postJson('/api/auth/passkey/register/start', { username });
          const cred = await navigator.credentials.create({ publicKey: toCreationOptions(start) });
          if (!cred) throw new Error('no credential created');
          const att = cred.response;
          const payload = {
            username,
            id_b64: cred.id,
            raw_id_b64: bytesToB64u(new Uint8Array(cred.rawId)),
            type: cred.type,
            response: {
              attestationObject_b64: bytesToB64u(new Uint8Array(att.attestationObject)),
              clientDataJSON_b64: bytesToB64u(new Uint8Array(att.clientDataJSON)),
            }
          };
          const fin = await postJson('/api/auth/passkey/register/finish', payload);
          console.log('register finish', fin);
          alert('Passkey registration: ' + (fin && fin.error ? fin.error : 'done'));
        } catch (e) {
          console.error('register error', e);
          alert('Register failed: ' + e);
        }
      };

      const onLoginClick = async () => {
        const username = prompt('Username for passkey sign-in:')?.trim();
        if (!username) return;
        try {
          const start = await postJson('/api/auth/passkey/login/start', { username });
          if (start && start.error) { alert('No credentials for user'); return; }
          const assertion = await navigator.credentials.get({ publicKey: toRequestOptions(start) });
          if (!assertion) throw new Error('no assertion');
          const res = assertion.response;
          const payload = {
            username,
            id_b64: assertion.id,
            raw_id_b64: bytesToB64u(new Uint8Array(assertion.rawId)),
            type: assertion.type,
            response: {
              authenticatorData_b64: bytesToB64u(new Uint8Array(res.authenticatorData)),
              clientDataJSON_b64: bytesToB64u(new Uint8Array(res.clientDataJSON)),
              signature_b64: bytesToB64u(new Uint8Array(res.signature)),
              userHandle_b64: res.userHandle ? bytesToB64u(new Uint8Array(res.userHandle)) : ''
            }
          };
          const fin = await postJson('/api/auth/passkey/login/finish', payload);
          console.log('login finish', fin);
          alert('Passkey login: ' + (fin && fin.error ? fin.error : 'done'));
        } catch (e) {
          console.error('login error', e);
          alert('Login failed: ' + e);
        }
      };

      document.getElementById('btn-passkey-register').addEventListener('click', onRegisterClick);
      document.getElementById('btn-passkey-login').addEventListener('click', onLoginClick);
    </script>
    
  </body>
</html>
