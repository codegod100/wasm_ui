<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Odin WASM UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    #console { background: #111; color: #eee; padding: 8px 10px; border-radius: 6px; white-space: pre-wrap; }
    #app { max-width: 560px; }
    .chat-header { font-weight: 600; margin-bottom: 8px; }
    .chat-list { border: 1px solid #ddd; border-radius: 8px; padding: 8px; height: 260px; overflow-y: auto; }
    .chat-row { padding: 4px 6px; border-bottom: 1px dashed #eee; }
    .chat-row:last-child { border-bottom: none; }
    .chat-actions { margin-top: 8px; }
    .chat-actions button { margin-right: 8px; padding: 4px 8px; }
  </style>
  <script src="odin.js"></script>
  <script>
    // Hold a WasmMemoryInterface so we can access exports for callbacks
    const wmi = new odin.WasmMemoryInterface();

    // Provide imports for Odin's `foreign import "js"` stubs via extra imports
    // Simple handle table for DOM nodes (WASM passes u32 handles, not JS objects)
    const H = { next: 1, table: Object.create(null) };
    const hput = (obj) => { const id = H.next++; H.table[id] = obj; return id; };
    const hget = (id) => H.table[id];

    const s = (ptr, len) => wmi.loadString(ptr, len);

    const extraImports = {
      js: {
        js_query_selector: (sel_ptr, sel_len) => hput(document.querySelector(s(sel_ptr, sel_len))),
        js_create_element: (tag_ptr, tag_len) => hput(document.createElement(s(tag_ptr, tag_len))),
        js_create_text_node: (text_ptr, text_len) => hput(document.createTextNode(s(text_ptr, text_len))),
        js_set_attr: (el, name_ptr, name_len, value_ptr, value_len) => hget(el)?.setAttribute(s(name_ptr, name_len), s(value_ptr, value_len)),
        js_append_child: (parent, child) => hget(parent)?.appendChild(hget(child)),
        js_remove_children: (el) => { const e = hget(el); if (!e) return; while (e.firstChild) e.removeChild(e.firstChild); },
        js_add_event: (el, ev_ptr, ev_len, id) => {
          const e = hget(el);
          if (!e) return;
          const name = s(ev_ptr, ev_len);
          if (name === 'enter') {
            e.addEventListener('keydown', (evt) => {
              if (evt.key === 'Enter') {
                if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                  wmi.exports.on_event(id);
                }
              }
            });
          } else {
            e.addEventListener(name, () => {
              if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                wmi.exports.on_event(id);
              }
            });
          }
        },
        js_get_value_by_id: (id_ptr, id_len, dst_ptr, dst_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return 0;
          const val = (el.value != null ? String(el.value) : '');
          const toWrite = val.slice(0, dst_len);
          return wmi.storeString(dst_ptr, toWrite);
        },
        js_set_value_by_id: (id_ptr, id_len, value_ptr, value_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.value = s(value_ptr, value_len);
        },
        js_focus_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (el && typeof el.focus === 'function') el.focus();
        },
        js_scroll_to_bottom_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.scrollTop = el.scrollHeight;
        },
        // Fetch bridge (very simple, last-result cache)
        js_fetch_get: (url_ptr, url_len, cb_id) => {
          const url = s(url_ptr, url_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = {};
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'GET', headers })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_fetch_post_json: (url_ptr, url_len, body_ptr, body_len, cb_id) => {
          const url = s(url_ptr, url_len);
          const body = s(body_ptr, body_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = { 'content-type': 'application/json' };
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'POST', headers, body })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_get_fetch_body: (dst_ptr, dst_len) => {
          const txt = (window.__fetchCache && window.__fetchCache.body) || '';
          return wmi.storeString(dst_ptr, txt.slice(0, dst_len));
        },
        js_get_fetch_status: () => (window.__fetchCache && window.__fetchCache.status) || 0,
        js_set_auth_token: (tok_ptr, tok_len) => {
          window.__authToken = s(tok_ptr, tok_len);
        },
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      const pre = document.getElementById('console');
      // Build path must match the output you generate with `odin build` below
      odin.runWasm('./ui.wasm', pre, extraImports, wmi).catch(err => {
        console.error('Failed to run WASM', err);
      });
    });
  </script>
  </head>
  <body>
    <h1>Odin WASM UI</h1>
    <div id="app"></div>
    <script>
      // Basic styling hooks used by the Odin side
      const styleObserver = new MutationObserver(() => {
        const app = document.getElementById('app');
        if (!app) return;
        // Add classes to elements by their order to make it look chatty
        const [header, list, actions] = app.children;
        if (header) header.classList.add('chat-header');
        if (list)   list.classList.add('chat-list');
        if (list)   [...list.children].forEach(c => c.classList.add('chat-row'));
        if (actions) actions.classList.add('chat-actions');
      });
      styleObserver.observe(document.getElementById('app'), { childList: true, subtree: true });
    </script>
    <h3>Console</h3>
    <pre id="console"></pre>
  </body>
</html>
