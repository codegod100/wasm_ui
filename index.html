<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Odin WASM UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    #app { max-width: 560px; }
    .chat-header { font-weight: 600; margin-bottom: 8px; }
    .chat-list { border: 1px solid #ddd; border-radius: 8px; padding: 8px; height: 260px; overflow-y: auto; }
    .chat-row { padding: 4px 6px; border-bottom: 1px dashed #eee; }
    .chat-row:last-child { border-bottom: none; }
    .chat-actions { margin-top: 8px; }
    .chat-actions button { margin-right: 8px; padding: 4px 8px; }
    /* Loading spinner */
    .loading { display: inline-flex; align-items: center; gap: 8px; color: #555; }
    .spinner { width: 18px; height: 18px; border: 3px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
  <script src="odin.js"></script>
  <script src="./auth.js"></script>
  <script>
    // Hold a WasmMemoryInterface so we can access exports for callbacks
    const wmi = new odin.WasmMemoryInterface();

    // Provide imports for Odin's `foreign import "js"` stubs via extra imports
    // Simple handle table for DOM nodes (WASM passes u32 handles, not JS objects)
    const H = { next: 1, table: Object.create(null) };
    const hput = (obj) => { const id = H.next++; H.table[id] = obj; return id; };
    const hget = (id) => H.table[id];

    const s = (ptr, len) => wmi.loadString(ptr, len);

    const extraImports = {
      js: {
        js_query_selector: (sel_ptr, sel_len) => hput(document.querySelector(s(sel_ptr, sel_len))),
        js_create_element: (tag_ptr, tag_len) => hput(document.createElement(s(tag_ptr, tag_len))),
        js_create_text_node: (text_ptr, text_len) => hput(document.createTextNode(s(text_ptr, text_len))),
        js_set_attr: (el, name_ptr, name_len, value_ptr, value_len) => hget(el)?.setAttribute(s(name_ptr, name_len), s(value_ptr, value_len)),
        js_append_child: (parent, child) => hget(parent)?.appendChild(hget(child)),
        js_remove_children: (el) => { const e = hget(el); if (!e) return; while (e.firstChild) e.removeChild(e.firstChild); },
        js_add_event: (el, ev_ptr, ev_len, id) => {
          const e = hget(el);
          if (!e) return;
          const name = s(ev_ptr, ev_len);
          if (name === 'enter') {
            e.addEventListener('keydown', (evt) => {
              if (evt.key === 'Enter') {
                if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                  wmi.exports.on_event(id);
                }
              }
            });
          } else {
            e.addEventListener(name, () => {
              if (wmi && wmi.exports && typeof wmi.exports.on_event === 'function') {
                wmi.exports.on_event(id);
              }
            });
          }
        },
        js_get_value_by_id: (id_ptr, id_len, dst_ptr, dst_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return 0;
          const val = (el.value != null ? String(el.value) : '');
          const toWrite = val.slice(0, dst_len);
          return wmi.storeString(dst_ptr, toWrite);
        },
        js_set_value_by_id: (id_ptr, id_len, value_ptr, value_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.value = s(value_ptr, value_len);
        },
        js_focus_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (el && typeof el.focus === 'function') el.focus();
        },
        js_scroll_to_bottom_by_id: (id_ptr, id_len) => {
          const el = document.getElementById(s(id_ptr, id_len));
          if (!el) return;
          el.scrollTop = el.scrollHeight;
        },
        // Fetch bridge (very simple, last-result cache)
        js_fetch_get: (url_ptr, url_len, cb_id) => {
          const url = s(url_ptr, url_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = {};
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'GET', headers })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_fetch_post_json: (url_ptr, url_len, body_ptr, body_len, cb_id) => {
          const url = s(url_ptr, url_len);
          const body = s(body_ptr, body_len);
          if (!window.__fetchCache) window.__fetchCache = { status: 0, body: '' };
          const headers = { 'content-type': 'application/json' };
          if (window.__authToken) headers['authorization'] = `Bearer ${window.__authToken}`;
          fetch(url, { method: 'POST', headers, body })
            .then(r => (window.__fetchCache.status = r.status, r.text()))
            .then(t => { window.__fetchCache.body = t; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); })
            .catch(() => { window.__fetchCache.status = 0; window.__fetchCache.body = ''; if (wmi?.exports?.on_event) wmi.exports.on_event(cb_id); });
        },
        js_get_fetch_body: (dst_ptr, dst_len) => {
          const txt = (window.__fetchCache && window.__fetchCache.body) || '';
          return wmi.storeString(dst_ptr, txt.slice(0, dst_len));
        },
        js_get_fetch_status: () => (window.__fetchCache && window.__fetchCache.status) || 0,
        js_set_auth_token: (tok_ptr, tok_len) => {
          window.__authToken = s(tok_ptr, tok_len);
        },
        js_has_auth_token: () => !!window.__authToken,
        js_set_current_user: (name_ptr, name_len) => {
          window.__currentUser = s(name_ptr, name_len);
        },
        js_get_current_user: (dst_ptr, dst_len) => {
          const name = window.__currentUser || '';
          return wmi.storeString(dst_ptr, name.slice(0, dst_len));
        },
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      // Initialize auth wiring and flush any queued logs
      Auth.init({
        onStatus: (msg, kind) => {
          const el = document.getElementById('auth-status');
          if (!el) return;
          el.textContent = msg || '';
          el.style.color = kind === 'error' ? '#b91c1c' : (kind === 'success' ? '#065f46' : '#6b7280');
        },
        onAfterLogin: (username, token) => {
          window.__currentUser = username || '';
          if (token) window.__authToken = token;
          try { sessionStorage.setItem('authUsername', username || ''); } catch {}
          if (wmi?.exports?.on_event) wmi.exports.on_event(60);
        },
        onLog: (line) => {
          const el = document.getElementById('auth-log');
          if (!el) return;
          el.textContent += line + '\n';
          el.scrollTop = el.scrollHeight;
        }
      });
      Auth.flushAuthLog(document.getElementById('auth-log'));
      const pre = null;
      // Restore session auth (if present)
      try {
        const t = sessionStorage.getItem('authToken');
        if (t) window.__authToken = t;
        const u = sessionStorage.getItem('authUsername');
        if (u) window.__currentUser = u;
      } catch {}
      // Build path must match the output you generate with `odin build` below
      odin.runWasm('./ui.wasm', pre, extraImports, wmi).then(() => {
        // Notify WASM to pick up restored username, if any
        if (window.__currentUser && wmi?.exports?.on_event) wmi.exports.on_event(60);
      }).catch(err => {
        const app = document.getElementById('app');
        if (app) app.innerHTML = '<div class="loading"><div class="spinner"></div><span>Failed to load UI</span></div>';
        console.error('Failed to run WASM', err);
      });
    });
  </script>
  </head>
  <body>
    <h1>Odin WASM UI</h1>
    <div id="app">
      <div class="loading">
        <div class="spinner"></div>
        <span>Loading UI…</span>
      </div>
    </div>
    <div style="margin-top:16px; padding-top:8px; border-top:1px solid #eee;">
      <!-- Passkey actions disabled for now -->
      <button id="btn-passkey-register" style="display:none">Register Passkey</button>
      <button id="btn-passkey-login" style="display:none">Sign in with Passkey</button>
      <button id="btn-bsky-login">Sign in with Bluesky</button>
      <div id="auth-status" style="margin-top:8px; min-height:20px; color:#6b7280;"></div>
      <pre id="auth-log" style="margin-top:6px; max-height:160px; overflow:auto; background:#0b1020; color:#d1d5db; padding:8px; border-radius:6px; font-size:12px;"></pre>
    </div>
    <script>
      // Basic styling hooks used by the Odin side
      const styleObserver = new MutationObserver(() => {
        const app = document.getElementById('app');
        if (!app) return;
        // Add classes to elements by their order to make it look chatty
        const [header, list, actions] = app.children;
        if (header) header.classList.add('chat-header');
        if (list)   list.classList.add('chat-list');
        if (list)   [...list.children].forEach(c => c.classList.add('chat-row'));
        if (actions) actions.classList.add('chat-actions');
      });
      styleObserver.observe(document.getElementById('app'), { childList: true, subtree: true });
    </script>
    <script>
      // Minimal helpers via Auth
      const b64uToBytes = Auth.b64uToBytes;
      const bytesToB64u = Auth.bytesToB64u;

      // Map server JSON into WebAuthn options
      const toCreationOptions = (opts) => ({
        rp: opts.rp,
        user: {
          id: b64uToBytes(opts.user.id_b64),
          name: opts.user.name,
          displayName: opts.user.displayName,
        },
        challenge: b64uToBytes(opts.challenge_b64),
        pubKeyCredParams: opts.pubKeyCredParams,
        timeout: opts.timeout,
        attestation: opts.attestation,
        authenticatorSelection: opts.authenticatorSelection,
        extensions: { credProps: true },
        excludeCredentials: (opts.excludeCredentials||[]).map(e => ({ type: e.type, id: b64uToBytes(e.id_b64) })),
      });

      const toRequestOptions = (opts) => ({
        challenge: b64uToBytes(opts.challenge_b64),
        timeout: opts.timeout,
        userVerification: opts.userVerification,
        allowCredentials: (opts.allowCredentials||[]).map(a => ({ type: a.type, id: b64uToBytes(a.id_b64), transports: (a.transports||'').split(',').filter(Boolean) })),
      });

      const postJson = async (url, body) => {
        const r = await fetch(url, { method: 'POST', headers: { 'content-type':'application/json' }, body: JSON.stringify(body) });
        const text = await r.text();
        if (!text) {
          if (!r.ok) throw new Error(`HTTP ${r.status} empty body`);
          return {};
        }
        try {
          const json = JSON.parse(text);
          if (!r.ok) throw new Error(json && json.error ? json.error : `HTTP ${r.status}`);
          return json;
        } catch (e) {
          if (!r.ok) throw new Error(`HTTP ${r.status} ${text.slice(0,160)}`);
          throw e;
        }
      };

      // Prevent overlapping WebAuthn requests (spec forbids concurrent calls)
      let __webauthnPending = false;
      let __webauthnAbortCtrl = null;
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      const setAuthStatus = (msg, kind = 'info') => {
        const el = document.getElementById('auth-status');
        if (!el) return;
        el.textContent = msg || '';
        el.style.color = kind === 'error' ? '#b91c1c' : (kind === 'success' ? '#065f46' : '#6b7280');
      };
      // Logs handled by Auth via onLog + flush

      const onBskyLoginClick = () => Auth.startBlueskyLogin();

      const onRegisterClick = async () => {
        const username = prompt('Username for passkey registration:')?.trim();
        if (!username) return;
        try {
          const start = await postJson('/api/auth/passkey/register/start', { username });
          const cred = await navigator.credentials.create({ publicKey: toCreationOptions(start) });
          if (!cred) throw new Error('no credential created');
          try {
            const ext = cred.getClientExtensionResults ? cred.getClientExtensionResults() : {};
            if (ext && ext.credProps) {
              console.log('credProps', ext.credProps);
              // Log whether a resident key was stored (for debugging)
              if (typeof ext.credProps.rk !== 'undefined') {
                console.log('discoverable credential:', !!ext.credProps.rk);
              }
            }
          } catch {}
          const att = cred.response;
          const payload = {
            username,
            id_b64: cred.id,
            raw_id_b64: bytesToB64u(new Uint8Array(cred.rawId)),
            type: cred.type,
            response: {
              attestationObject_b64: bytesToB64u(new Uint8Array(att.attestationObject)),
              clientDataJSON_b64: bytesToB64u(new Uint8Array(att.clientDataJSON)),
            }
          };
          const fin = await postJson('/api/auth/passkey/register/finish', payload);
          console.log('register finish', fin);
        } catch (e) {
          console.error('register error', e);
        }
      };

      const onLoginClick = async () => {
        // Usernameless login on click: show passkey picker (no username fallback here)
        // If a background conditional request is in-flight, abort it so this click can take over.
        if (__webauthnAbortCtrl) {
          try { __webauthnAbortCtrl.abort(); } catch {}
          // Wait briefly for the abort to propagate and clear pending flag
          const t0 = Date.now();
          while (__webauthnPending && Date.now() - t0 < 500) { await sleep(10); }
        }
        if (__webauthnPending) { console.debug('WebAuthn still settling; try again'); return; }
        __webauthnPending = true;
        const btn = document.getElementById('btn-passkey-login');
        const prev = btn ? btn.textContent : '';
        if (btn) { btn.disabled = true; btn.textContent = 'Opening passkey…'; }
        setAuthStatus('Contacting server…');
        try {
          const start = await postJson('/api/auth/passkey/login/conditional/start', {});
          const assertion = await navigator.credentials.get({
            mediation: 'optional', // modal picker on click
            publicKey: toRequestOptions({
              challenge_b64: start.challenge_b64,
              timeout: start.timeout,
              userVerification: start.userVerification,
              allowCredentials: [],
            })
          });
          if (!assertion) { console.info('No passkeys available for this site.'); return; }
          const res = assertion.response;
          const payload = {
            username: '',
            id_b64: assertion.id,
            raw_id_b64: bytesToB64u(new Uint8Array(assertion.rawId)),
            type: assertion.type,
            response: {
              authenticatorData_b64: bytesToB64u(new Uint8Array(res.authenticatorData)),
              clientDataJSON_b64: bytesToB64u(new Uint8Array(res.clientDataJSON)),
              signature_b64: bytesToB64u(new Uint8Array(res.signature)),
              userHandle_b64: res.userHandle ? bytesToB64u(new Uint8Array(res.userHandle)) : ''
            }
          };
          const fin = await postJson('/api/auth/passkey/login/finish', payload);
          console.log('login finish (usernameless)', fin);
          if (fin && fin.username) {
            // Persist session + push to WASM and trigger UI update
            window.__currentUser = fin.username;
            try { sessionStorage.setItem('authUsername', fin.username); } catch {}
            if (fin.token) {
              window.__authToken = fin.token;
              try { sessionStorage.setItem('authToken', fin.token); } catch {}
            }
            if (wmi?.exports?.on_event) wmi.exports.on_event(60);
            setAuthStatus(`Signed in as ${fin.username}`, 'success');
          }
          // no alert; UI updates via username/token set above
        } catch (e) {
          console.error('usernameless login error', e);
          const msg = (e && e.message) ? e.message : String(e);
          setAuthStatus(`Sign-in failed: ${msg}`, 'error');
        } finally {
          __webauthnPending = false;
          if (btn) { btn.disabled = false; btn.textContent = prev; }
        }
      };

      // Passkeys disabled: no event listeners
      // document.getElementById('btn-passkey-register').addEventListener('click', onRegisterClick);
      // document.getElementById('btn-passkey-login').addEventListener('click', onLoginClick);
      document.getElementById('btn-bsky-login').addEventListener('click', onBskyLoginClick);
      // Handle OAuth callback in full-window flow
      Auth.handleOAuthCallbackIfPresent();

      // Passkeys disabled: conditional mediation skipped
    </script>
    
  </body>
</html>
